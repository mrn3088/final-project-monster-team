<!DOCTYPE html>
<html>
<head>
  <!-- Include ZingGrid, ZingChart, and axios libraries -->
  <script src="https://cdn.zinggrid.com/zinggrid.min.js"></script>
  <script src="https://cdn.zingchart.com/zingchart.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <title>Data Visualization</title>
</head>
<body>
  <!-- Define your ZingGrid for Browser usage -->
  <zing-grid
    id="browserGrid"
    caption="Browser Usage"
    data='[]'>
    <zg-column index="browserType" header="Browser Type"></zg-column>
    <zg-column index="count" header="Count"></zg-column>
  </zing-grid>

  <!-- Define your ZingGrid for language usage -->
  <zing-grid
  id="languageGrid"
  caption="Language Usage"
  data='[]'>
  <zg-column index="language" header="Language"></zg-column>
  <zg-column index="count" header="Count"></zg-column>
  </zing-grid>

  <!-- Define your ZingChart for load times -->
  <div id="load-time-chart"></div>

  <!-- Define your activity data section -->
  <div id="activity">
    <h1>Activity Data Record</h1>
    <div id="userJSCookie"></div>
  </div>

  <div id="loadTimeDistributionChart"></div>

  <div id="languageLoadTimeChart"></div>

  <div id="browserLoadTimeChart"></div>


  <script>
    // Initialize arrays to store the counts of each browser type and language
    var browserData = [
      { browserType: 'Chrome', count: 0, loadTimes: [] },
      { browserType: 'Firefox', count: 0, loadTimes: [] },
      { browserType: 'Safari', count: 0, loadTimes: [] },
      { browserType: 'Internet Explorer', count: 0, loadTimes: [] },
      { browserType: 'Other', count: 0, loadTimes: [] }
    ];

    // Fetch data for browser usage from your Express app
    axios.get('https://cse135.monster/api/static')
      .then(response => {
        // Your existing logic for browserData here
        var records = response.data;
        if (!Array.isArray(records)) {
          console.error('Response data is not an array:', records);
          return;
        }
        for (var i = 0; i < records.length; i++) {
          var userAgent = records[i].userAgent;
          if (userAgent.includes('Chrome')) {
            browserData[0].count++;
          } else if (userAgent.includes('Firefox')) {
            browserData[1].count++;
          } else if (userAgent.includes('Safari')) {
            browserData[2].count++;
          } else if (userAgent.includes('Internet Explorer')) {
            browserData[3].count++;
          } else {
            browserData[4].count++;
          }
        }
        // Update the ZingGrid with the new data
        document.getElementById('browserGrid').setData(browserData);
      })
      .catch(error => {
        console.error('Error fetching browser data:', error);
      });

      axios.get('https://cse135.monster/api/static')
      .then(response => {
        let languageData = [];

        let data = response.data;
        let enCount = 0;
        let zhCount = 0;

        for (let i = 0; i < data.length; i++) {
          let value = data[i];
          let language = value.language;

          if (language.includes("en-US")) {
            enCount++;
          } else if (language.includes("zh-CN")) {
            zhCount++;
          }
        }

        languageData.push({
          language: "en-US",
          count: enCount
        });

        languageData.push({
          language: "zh-CN",
          count: zhCount
        });

        // Update the ZingGrid with the new data
        document.getElementById('languageGrid').setData(languageData);
      })
      .catch(error => {
        console.error('Error fetching language data:', error);
      });

      
    // Fetch data for performance from your Express app
    axios.get('https://cse135.monster/api/performance')
      .then(response => {
        let loadTimes = [];
        let loadTimeCounts = {};

        let data = response.data;

        for (let i = 0; i < data.length; i++) {
          let value = data[i];
          let startLoad = value.pageStartLoad;
          let endLoad = value.pageEndLoad;
          let loadTime = endLoad - startLoad;

          loadTimes.push(loadTime);
          
          let browserType = value.browserType;

          // Find the corresponding browser data and add the load time
          for (let j = 0; j < browserData.length; j++) {
            if (browserData[j].browserType === browserType) {
              browserData[j].loadTimes.push(loadTime);
              break;
            }
          }
        }

        for (let i = 0; i < loadTimes.length; i++) {
          let loadTime = loadTimes[i];
          let zone = getLoadTimeZone(loadTime);

          if (!loadTimeCounts[zone]) {
            loadTimeCounts[zone] = 0;
          }

          loadTimeCounts[zone]++;
        }

        let totalLoadTimes = loadTimes.length;
        
        
        
        
        let loadTimeDistribution = [];

        for (let zone of loadTimeZones) {
          let count = loadTimeCounts[zone] || 0;
          let percentage = ((count / totalLoadTimes) * 100).toFixed(2);

          loadTimeDistribution.push({
            zone: zone,
            percentage: parseFloat(percentage)
          });
        }
                


        // Create the ZingChart configuration for load time distribution
        let loadTimeDistributionConfig = {
          type: 'bar',
          series: [
            {
              values: loadTimeDistribution.map(data => data.percentage),
              text: 'Load Time Distribution'
            }
          ],
          labels: {
            template: '%v%'
          },
          scaleX: {
            labels: loadTimeDistribution.map(data => data.zone),
            itemsOverlap: true,
            item: {
              angle: -45
            }
          },
          title : {
            text: "Load Time Distribution Chart"
          }
        };

        // Render the load time distribution chart
        zingchart.render({
          id: 'loadTimeDistributionChart',
          data: loadTimeDistributionConfig,
          height: '400',
          width: '600'
        });
         let browserAverageLoadTimes = browserData.map(data => {
          let averageLoadTime = calculateAverageLoadTime(data.loadTimes);
          return {
            browserType: data.browserType,
            averageLoadTime: parseFloat(averageLoadTime)
          };
        });

      })
      .catch(error => {
        console.error('Error fetching performance data:', error);
      });

    // Function to determine the load time zone
    function getLoadTimeZone(loadTime) {
      if (loadTime >= 0 && loadTime <= 100) {
        return '0-100 ms';
      } else if (loadTime > 100 && loadTime <= 200) {
        return '100-200 ms';
      } else if (loadTime > 200 && loadTime <= 300) {
        return '200-300 ms';
      } else if (loadTime > 300 && loadTime <= 400) {
        return '300-400 ms';
      } else {
        return '> 400 ms';
      }
    }

    let loadTimeZones = ['0-100 ms', '100-200 ms', '200-300 ms', '300-400 ms', '> 400 ms'];


        // Fetch data for performance and language from your Express app
    Promise.all([
      axios.get('https://cse135.monster/api/performance'),
      axios.get('https://cse135.monster/api/static')
    ])
      .then(([performanceResponse, languageResponse]) => {
        let loadTimeData = performanceResponse.data;
        let languageData = languageResponse.data;

        // Create an object to store language load time data
        let languageLoadTimeData = {};

        
        // Process load time data
        for (let i = 0; i < loadTimeData.length; i++) {
          let loadTimeItem = loadTimeData[i];
          let id = loadTimeItem.id;
          let loadTime = loadTimeItem.totalLoadTime;

          if (!languageLoadTimeData[id]) {
            languageLoadTimeData[id] = {
              loadTimes: [],
              language: ''
            };
          }

          languageLoadTimeData[id].loadTimes.push(loadTime);
        }

        // Process language data and calculate average load time
        let enLoadTimes = [];
        let zhLoadTimes = [];

        for (let i = 0; i < languageData.length; i++) {
          let languageItem = languageData[i];
          let id = languageItem.id;
          let language = languageItem.language;

          if (languageLoadTimeData[id]) {
            languageLoadTimeData[id].language = language;

            if (language === 'en-US') {
              enLoadTimes.push(...languageLoadTimeData[id].loadTimes);
            } else if (language === 'zh-CN') {
              zhLoadTimes.push(...languageLoadTimeData[id].loadTimes);
            }
          }
        }

        // Calculate average load time for each language
        let enAverageLoadTime = calculateAverageLoadTime(enLoadTimes);
        let zhAverageLoadTime = calculateAverageLoadTime(zhLoadTimes);

        // Create the ZingChart configuration for language and load time relationship
        let languageLoadTimeConfig = {
          type: 'bar',
          series: [
            {
              values: [parseFloat(enAverageLoadTime), parseFloat(zhAverageLoadTime)],
              text: 'Average Load Time'
            }
          ],
          labels: {
            template: '%v ms'
          },
          scaleX: {
            labels: ['en-US', 'zh-CN']
          },
          scaleY: {
            values: '0:400:100'
          },
          title: {
            text: "Average loading time for different languages"
          }
        };

        // Render the language and load time relationship chart
        zingchart.render({
          id: 'languageLoadTimeChart',
          data: languageLoadTimeConfig,
          height: '400',
          width: '600'
        });
      })
      .catch(error => {
        console.error('Error fetching performance and language data:', error);
      });

    // Function to calculate the average load time
    
    // Initialize objects to store the counts of each browser type and the total load times

    // Calculate average load time for each browser
    let browserAverageLoadTimes = browserData.map(data => {
      let averageLoadTime = calculateAverageLoadTime(data.loadTimes);
      return {
        browserType: data.browserType,
        averageLoadTime: parseFloat(averageLoadTime)
      };
    });

    // Create the ZingChart configuration for browser and load time relationship
    var browserLoadData = [
    { browserType: 'Chrome', loadTimes: [] },
    { browserType: 'Firefox', loadTimes: [] },
    { browserType: 'Safari', loadTimes: [] },
    { browserType: 'Internet Explorer', loadTimes: [] },
    { browserType: 'Other', loadTimes: [] }
  ];

  axios.all([
    axios.get('https://cse135.monster/api/performance'), 
    axios.get('https://cse135.monster/api/browser')
  ])
  .then(axios.spread((performanceResponse, browserResponse) => {
    var performanceRecords = performanceResponse.data;
    var browserRecords = browserResponse.data;

    // First, create a map of browser types by id
    var browserMap = {};
    browserRecords.forEach(record => {
      browserMap[record.id] = record.browserType;
    });

    // Then, for each performance record, use the browser id to get the browser type
    for (var i = 0; i < performanceRecords.length; i++) {
      var record = performanceRecords[i];
      var loadTime = record.pageEndLoad - record.pageStartLoad;
      var browserType = browserMap[record.browserId];

      var browserData = browserLoadData.find(data => data.browserType === browserType);
      if (!browserData) {
        browserData = browserLoadData[browserLoadData.length - 1]; // 'Other' category
      }
      browserData.loadTimes.push(loadTime);
    }

    // Calculate average load time for each browser
    var browserAverageLoadTimes = browserLoadData.map(data => {
      var averageLoadTime = calculateAverageLoadTime(data.loadTimes);
      return {
        browserType: data.browserType,
        averageLoadTime: parseFloat(averageLoadTime)
      };
    });

    // Update the ZingGrid with the new data
    var grid = document.getElementById('browserLoadTimeGrid');
    grid.setData(browserAverageLoadTimes);
  }))
  .catch(error => {
    console.error('Error fetching data:', error);
  });

  // Function to calculate the average load time
  function calculateAverageLoadTime(loadTimes) {
    if (loadTimes.length === 0) {
      return '0.00';
    }

    var sum = loadTimes.reduce((acc, val) => acc + val, 0);
    var averageLoadTime = sum / loadTimes.length;

    return averageLoadTime.toFixed(2); // Keep as string to maintain decimal precision
  }

  </script>
</body>
</html>
